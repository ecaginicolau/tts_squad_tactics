--------------------------------------
--- Package that represents the Board's data itself
--- Contains few utilities functions
--- ex: convert position to coordinate and the other way around


-- No local, make it a global
Board = {
    size_x = 0,
    size_y = 0,
    data = { },
    actions = {},
    miniatures = {},
    coordinate_team = {},
    world_size_x = 0,
    world_size_y = 0,
    bounds = {},
    bounds_normalized = {}
}

-- this help loops through all directions
local hinder_direction = {
    { 0, 0 },
    { 0, 1 },
    { 1, 0 },
    { 0, -1 },
    { -1, 0 },
    { 1, 1 },
    { 1, -1 },
    { -1, 1 },
    { -1, -1 },
}

function Board.setup(size_x, size_y, data)
    Board.size_x = size_x
    Board.size_y = size_y
    Board.data = data
    Board.miniatures = {}
    -- will store ongoing action by player_color
    Board.actions = {}
    Board.coordinate_team = {}

    -- calculate and store the bounds
    Board.bounds = self.getBounds() -- extract it at setup because it cal change with the UI!
    Board.bounds_normalized = self.getBoundsNormalized() -- extract it at setup because it cal change with the UI!

    Board.calculate_team()
    Board.calculate_dimension()
    return Board
end

function Board.calculate_dimension()
    local world_size = Board.bounds["size"]
    Board.world_size_x = world_size[1] / Board.size_x
    Board.world_size_y = world_size[3] / Board.size_y
end

function Board.calculate_team()
    Board.coordinate_team = {}

    for y = 1, Board.size_y, 1 do
        Board.coordinate_team[y] = {}
        for x = 1, Board.size_x, 1 do
            -- store a list of team
            Board.coordinate_team[y][x] = {  }
        end
    end
    for _, miniature in pairs(Board.miniatures) do
        local coordinate = miniature["coordinate"]
        for _, direction in ipairs(hinder_direction) do
            local dx = coordinate[1] + direction[1]
            local dy = coordinate[2] + direction[2]
            if Board.is_inside({ dx, dy }) then
                -- insert in the list of team
                table.insert(Board.coordinate_team[dy][dx], miniature["team"])
            end
        end
    end
end

function Board.get_position(x, y)
    local bounds = Board.bounds
    local size = bounds['size']
    local center = bounds['center']
    -- the initial position will be the top left corner
    local pos_x = center[1] - size[1] / 2
    local pos_y = center[2] + size[2] / 2 + 0.1
    local pos_z = center[3] + size[3] / 2
    -- now add the x and y
    pos_x = pos_x + (x - 0.5) * (size[1] / Board.size_x)
    pos_z = pos_z - (y - 0.5) * (size[3] / Board.size_y)

    return Vector.new(pos_x, pos_y, pos_z)
end

function Board.get_position_relative(x, y)
    local position = Board.get_position(x, y)
    -- apply scale
    local scale = self.getScale()
    local pos_x = position[1]
    local pos_y = position[2]
    local pos_z = position[3]
    -- add the center
    local center = Board.bounds['center']
    pos_x = pos_x - center[1]
    pos_y = pos_y - center[2]
    pos_z = pos_z - center[3]

    pos_x = -pos_x / scale[1] -- not sure why this coordinate has x axis inverted
    pos_y = pos_y / scale[2]
    pos_z = pos_z / scale[3]

    return Vector.new(pos_x, pos_y, pos_z)
end

function Board.get_cover_status_face(x, y, face)
    local direction = Constant.DIRECTIONS[face]
    local dx = direction[1] + x
    local dy = direction[2] + y
    return Board.get_cover_status(x, y, dx, dy)
end

-- this function return an integer, 0 : no cover, 1 semi cover, 2 full cover
function Board.get_cover_status(x1, y1, x2, y2)
    -- make sure both coordinate are inside the board
    if not Board.is_inside({ x1, y1 }) then
        return 0
    end
    if not Board.is_inside({ x2, y2 }) then
        return 0
    end
    -- they are in the board, handle value
    -- We only need the value of the 2nd tile
    local tile_value = Board.data[y2][x2]
    return Constant[tile_value].cover
end

function Board.reset()
    Board.data = {}
    for y = 1, Board.size_y, 1 do
        Board.data[y] = {}
        for x = 1, Board.size_x, 1 do
            Board.data[y][x] = Constant.WALKABLE.value
        end
    end
end

function Board.get_coordinate(position, rounded)
    -- by default it's rounded
    if rounded == nil then
        rounded = false
    end
    local bounds = Board.bounds
    local center = bounds['center']
    local size = bounds['size']
    local pos_x = -center[1] + position[1] + size[1] / 2.0
    local pos_y = center[3] - position[3] + size[3] / 2.0

    local cell_size_x = size[1] / Board.size_x
    local cell_size_y = size[3] / Board.size_y

    pos_x = pos_x - cell_size_x / 2
    pos_y = pos_y - cell_size_y / 2

    pos_x = pos_x / cell_size_x + 1 -- don't forget to add 1 to be LUA compliant
    pos_y = pos_y / cell_size_y + 1 -- don't forget to add 1 to be LUA compliant

    if not rounded then
        pos_x = math.tointeger(pos_x)
        pos_y = math.tointeger(pos_y)
    else
        pos_x = math.round(pos_x, 2)
        pos_y = math.round(pos_y, 2)
    end

    return { pos_x, pos_y }
end

function Board.is_inside(coordinate)
    if coordinate[1] < 1 or coordinate[1] > Board.size_x or coordinate[2] < 1 or coordinate[2] > Board.size_y then
        return false
    end
    return true
end

function Board.create_snap_points()
    local bounds = Board.bounds_normalized
    local size = bounds['size']
    -- The list of all snap points of this objects, this will overwrite any old snap points
    local list_snap_points = {}
    local scale = self.getScale()
    -- Apply scale to size because the snap point are pure relative
    size[1] = size[1] / scale[1]
    size[2] = size[2] / scale[2]
    size[3] = size[3] / scale[3]

    -- Always put on top of the board
    local pos_y = size[2] / 2

    for y = 1, Board.size_y, 1 do
        for x = 1, Board.size_x, 1 do
            local pos_x = -size[1] / 2 + ((x - 0.5) / Board.size_x) * size[1]
            local pos_z = -size[3] / 2 + ((y - 0.5) / Board.size_y) * size[3]
            local snap_position = { pos_x, pos_y, pos_z }
            list_snap_points[#list_snap_points + 1] = { position = snap_position }
        end
    end
    self.setSnapPoints(list_snap_points)
end

function Board.next_value(value)
    -- Weird LUA modulo code , since any table starts at 1 ...
    local new_index = Constant[value].index % Constant.NB_TERRAINS + 1
    return Constant[Constant.TERRAINS[new_index]].value
end

-- Find all miniatures in the current board
function Board.find_miniatures()
    local list_miniature = getObjectsWithTag("miniature")
    Board.miniatures = {}
    for _, miniature in ipairs(list_miniature) do
        Board.add_new_miniature(miniature)
    end
    -- at the end calculate team influence
    Board.calculate_team()
end

function Board.add_new_miniature(miniature)
    local guid = miniature.getGUID()
    -- get the miniature coordinate
    local coordinate = Board.get_coordinate(miniature.getPosition())

    local miniature_data = miniature.call("get_data")
    -- Hack to avoid mutable issue
    local data = {}
    local list_keys = {}
    for key, _ in pairs(miniature_data) do
        table.insert(list_keys, key)
    end
    -- Copy the data
    for _, key in pairs(list_keys) do
        if type(miniature_data[key]) == "table" then
            data[key] = table.clone(miniature_data[key])
        else
            data[key] = miniature_data[key]
        end
    end

    -- store the miniature inside the table
    Board.miniatures[guid] = data
    Board.miniatures[guid].coordinate = coordinate
end

function Board.miniatures_color(player_color)
    local list_miniatures = {}
    for _, miniature in pairs(Board.miniatures) do
        if player_color == "All" or miniature["owner"] == player_color then
            table.insert(list_miniatures, miniature)
        end
    end

    return list_miniatures
end

function Board_miniatures_color(params)

    return Board.miniatures_color(params[1])
end

function Board.start_action(player_color, guid, action, value)
    -- Store the current action for the player
    Board.actions[player_color] = {
        action = action,
        guid = guid,
        value = value,
    }
    -- Check action type, both MOVE and SAFE_MOVE are similar
    if action == Constant.MOVE or action == Constant.SAFE_MOVE then
        print("Start action")
        local nb_move = tonumber(value)
        local safe = action == Constant.SAFE_MOVE
        Board.move_start(player_color, guid, nb_move, safe)
    end
    if action == Constant.ATTACK then
        local cone = getObjectFromGUID("9b3ed5")
        local board_scale = Board_get_scale()
        --local miniature = getObjectFromGUID(guid)
        local coordinate = Board.miniatures[guid].coordinate
        -- take the position from the coordinate to avoid the small involuntary movement
        local position = Board.get_position(coordinate[1], coordinate[2])
        position[2] = position[2] + 0.1 -- raise the cone a bit higher than the board
        local angle = 60
        local length = 6
        cone.call("Cone_create", { player_color, guid, angle, length, position, coordinate, board_scale , self})
    end

end

-- Start of the move action
function Board.move_start(player_color, guid, nb_move, safe)
    -- calculate the pathfinding
    PathFinding.calculate(guid, nb_move, safe)

    -- Display the Player panel under the miniature
    PlayerPanel.start_move(player_color, guid, nb_move)
end

function Board.move_to(player_color, coordinate)
    -- Hide the PlayerPanel
    PlayerPanel.display(player_color, false)
    -- We received an move to command, need to find which miniature was moving
    local action = Board.actions[player_color]
    if action == nil then
        print("ERROR: no action started")
        return
    end

    local guid = action.guid
    local miniature = getObjectFromGUID(guid)
    local current_position = miniature.getPosition()
    local next_position = Board.get_position(coordinate[1], coordinate[2])

    -- we need to replace the Y component
    next_position[2] = current_position[2]

    -- Get the path
    local path_coordinates = Board.find_path(guid, coordinate)
    if path_coordinates ~= nil then
        -- move the miniature along the path
        -- convert to position path
        local path = {}
        for _, path_coordinate in ipairs(path_coordinates) do
            local path_position = Board.get_position(path_coordinate[1], path_coordinate[2])
            -- make sure to always set the y position to the miniature  position
            path_position[2] = current_position[2]
            -- insert into the position path
            table.insert(path, path_position)
        end

        -- rotate the miniature to the first coordinate
        local angle = angle_coordinate(path_coordinates[1], coordinate)
        miniature.setRotationSmooth({ 0, angle, 0 })

        -- store the fact that the miniature is moving inside the action
        action.is_moving = true
        action.destination = coordinate

        local end_move_func = function()
            Board.move_end(player_color, guid)
        end

        Path.start_path(guid, path, end_move_func)
    else
        print("no valid path, teleport")
        miniature.setPosition(next_position)
        -- End the move
        Board.move_end(player_color, guid)
    end

end

function Board.is_moving(player_color)
    local action = Board.actions[player_color]
    if action == nil then
        return false
    end
    if action.is_moving == nil then
        return false
    end
    -- check if the miniature is moving
    local miniature = getObjectFromGUID(action["guid"])
    return miniature.isSmoothMoving()
end

function Board.find_path(guid, coordinate)
    local x = coordinate[1]
    local y = coordinate[2]
    local cost = PathFinding.cache[guid][y][x]
    -- if it's an impossible coordinate no need to look for a path
    if cost == 99 then
        return nil
    end
    local path = { coordinate }
    while cost > 0 do
        local min_cost = cost
        local next_coordinate = { x, y }
        -- look in every direction which tile is the cheapest to move to, for the shortest path
        for _, direction in ipairs(Constant.DIRECTIONS) do
            local dx = x + direction[1]
            local dy = y + direction[2]
            if Board.is_inside({ dx, dy }) then
                if PathFinding.cache[guid][dy][dx] < min_cost then
                    min_cost = PathFinding.cache[guid][dy][dx]
                    next_coordinate = { dx, dy }
                end
            end
        end
        -- check if we moved
        if cost == min_cost then
            -- We didn't move! error
            return nil
        end
        -- here we found the cheapest path, at it to the list
        table.insert(path, next_coordinate)
        -- prepare for next iteration
        cost = min_cost
        x = next_coordinate[1]
        y = next_coordinate[2]
    end
    -- reverse the path
    table.reverse(path)
    -- return the path
    return path
end

function Board.move_end(player_color, guid)
    print("Board.move_end")
    local miniature = getObjectFromGUID(guid)
    -- move the miniature on the board
    Board.move_miniature(miniature)
    -- Hide the PlayerPanel
    PlayerPanel.display(player_color, false)
    -- end the action
    Board.actions[player_color] = nil
end

function Board.move_miniature(miniature)
    -- get the old coordinate of this miniature
    local coordinate = Board.miniatures[miniature.getGUID()]["coordinate"]
    if coordinate ~= nil then
        -- hide the old tile
        BoardPanel.display(coordinate[1], coordinate[2], false)
    end
    -- move the miniature in its final position
    Board.set_miniature_position(miniature)
end

-- What should happen when the coordinate of a miniature change in the board
function Board.set_miniature_position(miniature)
    -- get the coordinate on the board for this miniature
    local coordinate = Board.get_coordinate(miniature.getPosition())

    -- store the position of this miniature
    local miniature_data = Board.miniatures[miniature.getGUID()]
    if miniature_data == nil then
        -- if it's the first time the miniature enter the board, add it to the board
        Board.add_new_miniature(miniature)
    else
        -- update its coordinate
        Board.miniatures[miniature.getGUID()]["coordinate"] = coordinate
    end

    -- Calculate new team hindering
    Board.calculate_team()

    -- show the new tile
    BoardPanel.display(coordinate[1], coordinate[2], true)

    -- call a debug function on this miniature, should do better later
    miniature.call("update_position", coordinate)
end


-- start and end turn events
function Board_start_turn()
    for guid, miniature in pairs(Board.miniatures) do
        local object = getObjectFromGUID(guid)
        if object ~= nil then
            local position = Board.get_position(miniature["coordinate"][1], miniature["coordinate"][2])
            local current_position = object.getPosition()
            -- transfer the Y component
            position[2] = current_position[2]
            object.setPosition(position)
            object.setLock(true)
        end
    end
end

function Board_end_turn()
    for guid, _ in pairs(Board.miniatures) do
        local object = getObjectFromGUID(guid)
        if object ~= nil then
            object.setLock(false)
        end
    end
end

-- Called by UI to update a miniature
function Board_update_miniature_data(params)
    local guid = params[1]
    local key = params[2]
    local value = params[3]
    Board.miniatures[guid][key] = value
end

function Board_update_miniature(params)
    local guid = params[1]
    local miniature = getObjectFromGUID(guid)
    Board.add_new_miniature(miniature)
end

function Board_get_scale()
    -- get the position of 2 tiles
    local position1 = Board.get_position(0, 0)
    local position2 = Board.get_position(10, 0)
    -- calculate the distance
    local distance = Vector.distance(position1, position2)
    return distance / 10
end

return Board
