dic_miniature_move_line = {}

function pathfindind_miniature(x, y, nb_move)
  -- This store the move cost for every tile
  local dic_move = {}
  -- initiatlise it to 99, unreachable
  for i = 1, size_y, 1 do
    dic_move[i] = {}
    for j = 1, size_x, 1 do
      dic_move[i][j] = 99 -- a number bigger than nb_move
    end
  end
  -- this help loops through all directions
  local list_direction = {
    {0, 1, false}, -- x, y, cost
    {1, 0, false}, -- x, y, cost
    {0, - 1, false}, -- x, y, cost
    { - 1, 0, false}, -- x, y, cost
    {1, 1, true}, -- x, y, cost
    {1, - 1, true}, -- x, y, cost
    { - 1, 1, true}, -- x, y, cost
    { - 1, - 1, true}, -- x, y, cost
  }

  -- should try to make a coroutine somehow (not sure both recursive and coroutine)
  function pathfindind_miniature_rec(x, y, cost, diagonal)
    -- exit condition, out of the board, out of move
    if x < 1 or x > size_x or y < 1 or y > size_y then
      return
    end

    local tile_value = board[y][x]

    -- exit condition, can't walk on this tile
    if tile_value == 0 or tile_value == 2 then
      return
    end

    local current_cost = 1
    if tile_value == 3 then
      current_cost = 2 -- 2 for semi cover
    end
    if diagonal then
      current_cost = current_cost * 1.4 -- 1.5 for the diagonal
    end

    cost = cost + current_cost

    -- another exit condition, the cost is greater than the available move nb
    if cost > nb_move then
      return
    end

    if dic_move[y][x] > cost then
      dic_move[y][x] = cost
      for _, direction in ipairs(list_direction) do
        pathfindind_miniature_rec(x + direction[1], y + direction[2], cost, direction[3])
      end
    end
  end

  -- Call the pathfind at the starting position
  pathfindind_miniature_rec(x, y, - 1, false)
  return dic_move
end

function pathfindind_miniature_update(guid)
  local coordinate = dic_miniature_position[guid]
  -- Calculate the path  finding
  local dic_move = pathfindind_miniature(coordinate[1], coordinate[2], nb_move)
  -- draw contour line
  local list_line_move = {}
  for y = 1, size_y, 1 do
    for x = 1, size_x, 1 do
      -- board_tile_display(x, y, dic_move[y][x] ~= 99)
      if dic_move[y][x] ~= 99 then
        pathfindind_create_line(x, y, dic_move, list_line_move)
      end
    end
  end
  print("need to draw lines: " .. #list_line_move)

  dic_miniature_move_line[guid] = {}
  for _, line in ipairs(list_line_move) do
    dic_miniature_move_line[guid][#dic_miniature_move_line[guid] + 1] = {
      points = {line[1], line[2]},
      color = line[3],
      thickness = 0.01,
      rotation = {0, 0, 0},
    }
  end
end


function pathfindind_create_line(x, y, dic_move, list_line_move)
  -- only draw line for walkable, if needed only
  if board[y][x] ~= 1 then
    return
  end

  local dic_color_vector = {
    {0, 0, 0, 0}, -- HIDDEN
    {1, 1, 0}, -- WALKABLE 4+
    {1, 0, 0}, -- Blocked
    {0, 0, 1}, -- SemiCover
    {0, 1, 0}, -- WALKABLE 4-
  }
  local face_delta = {
    { - 0.5, - 0.5}, -- face 1
    { 0.5, - 0.5}, -- face 2
    { 0.5, 0.5}, -- face 3
    { - 0.5, 0.5}, -- face 4
  }

  for face = 1, 4, 1 do
    local direction = direction[face]
    local dx = direction[1] + x
    local dy = direction[2] + y
    local color = nil

    if dx >= 1 and dx <= size_x and dy >= 1 and dy <= size_y then
      -- only draw this side if the next tile is walkable
      if board[dy][dx] >= 2 or dic_move[dy][dx] == 99 then
        color = dic_color_vector[board[dy][dx] + 1]
      end
      if dic_move[dy][dx] > 4 and dic_move[y][x] <= 4 and board[y][x] == 1 and board[dy][dx] == 1 then
        color = dic_color_vector[5]
      end
    else -- this handle the external border, it's too similar, should be merged
      color = dic_color_vector[board[y][x] + 1]
    end
    if color ~= nil then
      -- delta position for start point
      local ds = face_delta[face]
      -- delta position for end point, the point after the start point, so face + 1
      local de = face_delta[(face % 4) + 1] -- weird module in lua table

      local position1 = board_get_position_relative(x + ds[1], y + ds[2])
      local position2 = board_get_position_relative(x + de[1], y + de[2])
      list_line_move[#list_line_move + 1] = {position1, position2, color}
    end
  end
end

function pathfinding_show(guid)
  self.setVectorLines(dic_miniature_move_line[guid])
end
