

function raytrace(x0, y0, x1, y1)
  dx = math.abs(x1 - x0)
  dy = math.abs(y1 - y0)

  x = math.floor(x0)
  y = math.floor(y0)

  n = 1

  if dx == 0 then
    x_inc = 0
    error = 999999.9 -- infinity
  elseif x1 > x0 then
    x_inc = 1
    n = n + math.floor(x1) - x
    error = (math.floor(x0) + 1 - x0) * dy
  else
    x_inc = -1
    n = n + x - math.floor(x1)
    error = (x0 - math.floor(x0)) * dy
  end
  if dy == 0 then
    y_inc = 0
    error = -999999.9 -- -infinity
  elseif y1 > y0 then
    y_inc = 1
    n = n + math.floor(y1) - y
    error = error - (math.floor(y0) + 1 - y0) * dx
  else
    y_inc = -1
    n = n + y - math.floor(y1)
    error = error - (y0 - math.floor(y0)) * dx
  end

  local list_visted_tile = {}

  while n > 0 do
    n = n - 1
    -- print("Visit: " .. x ..", " .. y)
    list_visted_tile[#list_visted_tile + 1] = {x, y}
    if error > 0 then
      y = y + y_inc
      error = error - dx
    elseif error == 0 then -- diagonal exact, 2 step
      x = x + x_inc
      y = y + y_inc
      error = error - dx
      error = error + dy
      n = n - 1
    else
      x = x + x_inc
      error = error + dy
    end
  end

  return list_visted_tile
end


function los_miniature_all()
  for guid1, coordinate1 in pairs(dic_miniature_position) do
    los_miniature_single(guid1)
  end
end

function los_miniature_single(guid1, coordinate1, player_color)
  local list_line = {}
  -- self.setVectorLines({})
  function los_miniature_single_coroutine()
    for guid2, coordinate2 in pairs(dic_miniature_position) do
      if guid1 ~= guid2 then
        local visible = los_coordinate(coordinate1, coordinate2)
        -- coroutine.yield(0)
        if visible then
          los_couverture(coordinate1, coordinate2, list_line)
        end
      end
    end
    line_drawer_add_lines("los_"..player_color, list_line, player_color)
    return 1
  end
  startLuaCoroutine(self, "los_miniature_single_coroutine")
end


function los_tile_visible(x, y)
  -- print("los_tile_visible: " .. x .. ":" .. y)
  -- 0 is invisible and 2 is blocked, both block line of sight
  if x < 1 or x > size_x then
    return false
  end
  if y < 1 or y > size_y then
    return false
  end
  if board[y][x] == 0 or board[y][x] == 2 then
    return false
  end
  return true
end

function los_check_visted_tiled(list_visted_tile)
  for _, coordinate in ipairs(list_visted_tile) do
    if not los_tile_visible(coordinate[1], coordinate[2]) then
      return false
    end
  end
  return true
end

function los_coordinate(coordinate1, coordinate2)
  -- raytracing from slightly inside AND slightly outside the tile seems to remove most of the LoS issue, but double the nb of checks...
  local list_d1 = { - 0.01, 0.01, 0.99, 1.01} -- giggle around for the origin
  local list_d2 = { 0, 1} -- only use the real corner for the destination, it should divide by 4 the nb of ray
  -- Thats 64 rays in totals ... if we use list_d1 twice that would be 256 rays
  for _, dx1 in ipairs(list_d1) do
    coroutine.yield(0) -- this limite the nb of ray calculated per frame to 64
    for _, dy1 in ipairs(list_d1) do
      for _, dx2 in ipairs(list_d2) do
        for _, dy2 in ipairs(list_d2) do
          local list_visted_tile = raytrace(coordinate1[1] + dx1, coordinate1[2] + dy1, coordinate2[1] + dx2, coordinate2[2] + dy2)
          local line_visible = los_check_visted_tiled(list_visted_tile)
          if line_visible then
            -- no need to continue if we need it's visible
            return true
          end
        end
      end
    end
  end

  return false
end

function los_couverture(coordinate1, coordinate2,list_line)
  local dx = coordinate1[1] - coordinate2[1]
  local dy = coordinate1[2] - coordinate2[2]
  local direction = nil
  if math.abs(dx) > math.abs(dy) then
    direction = {dx / math.abs(dx), 0 }
  elseif math.abs(dx) < math.abs(dy) then
    direction = {0, dy / math.abs(dy), }
  else -- equal
    direction = {0, 0}
  end
  local x = coordinate2[1] + direction[1]
  local y = coordinate2[2] + direction[2]


  local color = nil
  if board[y][x] == 1 then
    color = {0, 1, 0}
  elseif board[y][x] == 2 then
    color = {1, 0, 0}
  elseif board[y][x] == 3 then
    color = {0, 0, 1}
  end
  if color ~= nil then
    local pos1 = board_get_position(coordinate1[1], coordinate1[2])
    local pos2 = board_get_position(coordinate2[1], coordinate2[2])
    list_line[#list_line + 1] = {
      points = {pos1, pos2},
      color = color,
      thickness = 0.05,
      rotation = {0, 0, 0},
    }
  end
end
